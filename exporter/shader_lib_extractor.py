from pprint import *
import re
import json
from collections import OrderedDict

uniforms = '''
uniform mat3 rotation_matrix_inverse;
uniform mat4 model_view_matrix;
uniform mat4 model_view_matrix_inverse;
uniform mat4 projection_matrix;
uniform mat4 projection_matrix_inverse;
'''

defines = '''
#define USE_NEW_SHADING
#ifndef BG_LOD
#define BG_LOD 0.0
#endif
'''

replacements = [
    # workaround for android glitch in some phones such as the Pixel
    ('gl_FrontFacing', 'true'),

    ('''/* These are needed for high quality bump mapping */
#version 130
#extension GL_ARB_texture_query_lod: enable
#define BUMP_BICUBIC''',''),
    # matrices, some are used in mat_code_generator.py
    # and some are removed just so it compiles
    ('gl_ModelViewMatrixInverse','model_view_matrix_inverse'),
    ('gl_ModelViewMatrix','model_view_matrix'),
    ('gl_ProjectionMatrixInverse','projection_matrix_inverse'),
    #('gl_ProjectionMatrix[3][3]','0.0'),
    ('gl_ProjectionMatrix','projection_matrix'),
    ('gl_NormalMatrixInverse','mat3(1)'),
    ('gl_NormalMatrix','mat3(1)'),

    # "simple" shadows, they're impossible without shadow2D[Proj]

    ('result = shadow2DProj(shadowmap, co).x;',
      '{result = texture2DProj(shadowmap, co).x;\n'
      'result = smoothstep(co.z, co.z+0.05, result);}'),
    # old shaders
    ('gl_LightSource[i].position','vec3(0,0,0)'),
    ('gl_LightSource[i].diffuse','vec3(0,0,0)'),
    ('gl_LightSource[i].specular','vec3(0,0,0)'),
    ('gl_LightSource[i].halfVector','vec3(0,0,0)'),
    ('float rad[4], fac;', 'float rad[4];float fac;'),

    # newer shaders (2.78)
    ('(normalize(vec).z + 1)', '(normalize(vec).z + 1.0)'),
    ('strength * v1 + (1 - strength) * v2', 'strength * v1 + (1.0 - strength) * v2'),
    ('int(x) - ((x < 0) ? 1 : 0)', 'int(x) - ((x < 0.0) ? 1 : 0)'),
    ('return x - i;', 'return x - float(i);'),
    ('(M_PI * 2)', '(M_PI * 2.0)'),
    ('((mod(xi, 2) == mod(yi, 2)) == bool(mod(zi, 2)))', 'true'),
    (re.compile(r'if \(depth > (\d)\) {'), r'if (depth > \1.0) {'),
    ('fac = 1;', 'fac = 1.0;'),
    ('outv = -v;','outv = vec3(0.0)-v;'),
    # 2.79
    ('Cdlum > 0 ?', 'Cdlum > 0.0 ?'),

    # PBR branch
    ('#extension GL_EXT_gpu_shader4: enable', ''),
    ('sampler1D', 'sampler2D'),
    (   'texture1DLod(unflutsamples, (float(u) + 0.5) / float(BSDF_SAMPLES), 0.0).rg;',
     'texture2DLod(unflutsamples, vec2((float(u) + 0.5) / float(BSDF_SAMPLES), 0.5), 0.0).rg;'),
    (re.compile(r'(#define BSDF_SAMPLES \d+)'),r'\1.0'),
    (re.compile(r'(#define LTC_LUT_SIZE \d+)'),r'\1.0'),
    ('int NOISE_SIZE = 64;','float NOISE_SIZE = 64.0;'),
    ('	Xi.yz = texelFetch(unflutsamples, u, 0).rg;\n'*2,''), # This one is triplicated
    ('< 0)','< 0.0)'),
    ('>0)','>0.0)'),
    (' 2 *',' 2.0 *'),
    (' 4 *',' 4.0 *'),
    ('(1 +','(1.0 +'),
    ('(1 -','(1.0 -'),
    ('(1 *','(1.0 *'),
    ('(1 /','(1.0 /'),
    (' 1 / ',' 1.0 / '),
    ('- 1)','- 1.0)'),
    ('- 1;','- 1.0;'),
    ('1e15','1.0e15'),
    ('1.0f','1.0'),
    (', 2)',', 2.0)'), # pow
    ('/2,','/2.0,'),
    (' 1 -',' 1.0 -'),
    (' 2*',' 2.0*'),
    (' 3*',' 3.0*'),
    (' 8*',' 8.0*'),
    ('+ 4 ','+ 4.0 '),
    ('Y = 1;','Y = 1.0;'),
    ('ii -= i;','ii -= float(i);'),
    ('= 0)','= 0.0)'), # with exceptions below
    ('(config == 0.0)','(config == 0)'),
    ('(gradient_type == 0.0)','(gradient_type == 0)'),
    ('(n == 0.0)','(n == 0)'),
    ('float i = 0;','float i = 0.0;'),
    # we'll assign the uniform on run time
    (re.compile(r'(uniform vec3 node_wavelength_LUT\[81\]).*?\);', flags=re.DOTALL),r'\1;'),
    ('transpose(mat3(T1, T2, N))','mat3(T1.x, T2.x, N.x, T1.y, T2.y, N.y, T1.z, T2.z, N.z)'),

    # disable dynamic loops in webgl1
    ('uniform vec2 unfbsdfsamples;', '''
#if __VERSION__ < 130
#define unfbsdfsamples vec2(1.0)
#define bsdf_samples 1.0
#else
uniform vec2 unfbsdfsamples;
#define bsdf_samples unfbsdfsamples.x
#endif
    '''),
    # ('for (float i = 0.0; i < unfbsdfsamples.x; i++) {',
    # 'float i; for (int iii = 0; iii < 32; iii++) { i = float(iii);'),

    # Replacing spherical harmonics by the ones generated by cubemap-sh
    ('vec3 sh = vec3(0.0);',
     '''float x = -N.x, y = -N.y, z = -N.z;
        return unfsh0 +
        unfsh1 * x +
        unfsh2 * y +
        unfsh3 * z +
        unfsh4 * z * x +
        unfsh5 * y * z +
        unfsh6 * y * x +
        unfsh7 * (3.0 * z * z - 1.0) +
        unfsh8 * (x*x - y*y);
    }
    vec3 orig_spherical_harmonics_L2(vec3 N){
        vec3 sh = vec3(0.0);'''),

    # World vector for background_transform_to_world and node_tex_coord_background
    # but using only one matrix uniform
    ('co_homogenous = (projection_matrix_inverse * v);', 'co_homogenous = v;'),
    ('(model_view_matrix_inverse * co).xyz', '(rotation_matrix_inverse * co.xyz)'),
    # bad fix for equirectangular seams (must set BG_LOD)
    ('color = texture2D(ima, vec2(u, v));', 'color = texture2DLod(ima, vec2(u, v), BG_LOD);'),

    # Same name of variable and function doesn't work in ANGLE
    (re.compile(r'disk_energy(?!\()', flags=re.DOTALL), r'd_energy'),

    # Avoid using ints in WebGL 1, it seems they don't quite work well
    ('int xi = int(abs(floor(p.x)));', '''
    float xi = (abs(floor(p.x)));
	float yi = (abs(floor(p.y)));
	float zi = (abs(floor(p.z)));
	bool check = ((mod(xi, 2.0) == mod(yi, 2.0)) == bool(mod(zi, 2.0)));
	color = check ? color1 : color2;
	fac = check ? 1.0 : 0.0;
    }
    void original_checker(vec3 p, vec4 color1, vec4 color2, float scale, out vec4 color, out float fac){
    int xi;
    '''),
    # don't use noise textures in webgl1
    ('texture2DLodEXT(unfjitter, (vec2(texel) + 0.5) / float(NOISE_SIZE), 0.0).rg',
    'vec2(1.0)'),
    ('texture2DLodEXT(unflutsamples, vec2((float(u) + 0.5) / float(BSDF_SAMPLES), 0.5), 0.0).rg',
    'vec2(1.0)'),
    # Webgl2
    ('texelFetch(unflutsamples, u, 0).rg',
    '(bsdf_samples>1.1)?texelFetch(unflutsamples, ivec2(u, 0), 0).rg:vec2(0.0)'),
    ('texelFetch(unfjitter, texel, 0).rg',
    '(bsdf_samples>1.1)?texelFetch(unfjitter, texel, 0).rg:vec2(0.0)'),
    (re.compile(r'\bsample\b', flags=re.DOTALL), r'sample_'),

    ('texture2DLodEXT(unfjitter, (vec2(texel) + 0.5) / float(NOISE_SIZE), 0.0).rg',
    '(bsdf_samples>1.1)?texture2DLodEXT(unfjitter, (vec2(texel) + 0.5) / float(NOISE_SIZE), 0.0).rg:vec2(1.0)'),
    ('texture2DLodEXT(unflutsamples, vec2((float(u) + 0.5) / float(BSDF_SAMPLES), 0.5), 0.0).rg',
    '(bsdf_samples>1.1)?texture2DLodEXT(unflutsamples, vec2((float(u) + 0.5) / float(BSDF_SAMPLES), 0.5), 0.0).rg:vec2(1.0)'),


    # Not sure why, noise doesn't work properly when BSDF_SAMPLES is too big here
    ('int u = int(mod(i + jitternoise.y * BSDF_SAMPLES, BSDF_SAMPLES));',
    'int u = int(mod(i + jitternoise.y * bsdf_samples, bsdf_samples));'),

    # ('setup_noise(gl_FragCoord.xy);', ''),

    # glsl-man parser limitations:
    # number literal suffixes
    # (this may not be a bug but actually GLSL ES not supporting them)
    (re.compile(r'\b([\d.]+)(u|f)\b', flags=re.DOTALL), r'\1'),
    # preprocessor in the middle of statements
    # TODO: rewrite it better so we can use backface
    ('#ifdef USE_BACKFACE\n'
    '			 && backface_depth_linear(ivec2(co.xy), 0) < ray.z + viewpos.z\n'
    '#endif\n', ''),
    # # TODO: Where is this coming from??
    # ('#ifdef USE_BACKFACE\n'
    # '			 && backface_depth(ivec2(co.xy), 0) < ray.z + viewpos.z\n'
    # '#endif\n', ''),

    # This moves a float declaration to before the #ifs
    # for compatibility with GLSL optimizer
    ('float dist = min', 'dist = min'),
    ('float dist = 1.0e15', 'dist = 1.0e15'),
    ('#ifdef CORRECTION_BOX', 'float dist;\n#ifdef CORRECTION_BOX'),
]

argument_replacements = [
    ('sampler2DShadow','sampler2D'),
]

alternate_bodies = {

}

# Make sure \r are removed before calling this
def get_patched_functions(lib):
    function_parts = re.compile(r"\n(\w+)\s+(\w+)\s*\((.*?)\)", flags=re.DOTALL).split(lib,)
    preamble = ['', '', '', function_parts[0]]
    #print(function_parts[0])
    function_parts = [preamble] + list(zip(
        function_parts[1::4], # return types
        function_parts[2::4], # name
        function_parts[3::4], # arguments (comma separated) # TODO: handle newlines?
        function_parts[4::4], # body and after body
    ))
    functions = OrderedDict()
    patched_bodies = []
    head = ''
    for rtype, name, args, body in function_parts:
        # reps = []
        if name in alternate_bodies and name not in patched_bodies:
            body = '{'+alternate_bodies[name]+'}'
            # patch only the first version of overloaded functions
            patched_bodies.append(name)
        else:
            for a,b in replacements:
                if isinstance(a,str):
                    new_body = body.replace(a,str(b))
                else:
                    new_body = a.sub(str(b), body)
                    a = str(a)
                if new_body != body:
                    # reps.append(a)
                    body = new_body
        #if reps:
            #print("Function {} has replacements for:\n    {}".format(
                #name or 'preamble', '\n    '.join(reps)))
        for a,b in argument_replacements:
            args = args.replace(a,str(b))
        if not name: # preamble
            function = body
        else:
            # all #if after the } belong to the next function
            next_head = ''
            a,b = body.rsplit('}', 1)
            if '\n#if' in b:
                b,c = b.split('#if', 1)
                body = a+'}'+b
                next_head = '#if'+c+'\n'
            function = "\n{}{} {}({}){}".format(head, rtype, name, args, body)
            head = next_head
        functions[name] = functions.get(name, '') + function
    return functions


SHADER_LIB = ""
debug_lib = False

def get_shader_lib(mat_list):
    global SHADER_LIB
    if True:
        ## For GPUs unsupported by PBR branch, put an exported scene json in
        ## /tmp/myou-shader-lib.json and uncomment this code
        # try:
        #     for ob in json.load(open('/tmp/myou-shader-lib.json')):
        #         if ob['type'] == 'SHADER_LIB':
        #             SHADER_LIB = ob['code']
        #             return SHADER_LIB
        # except:
        #     pass
        import bpy, gpu
        mat = bpy.data.materials.new('delete_me')
        fragment = gpu.export_shader(bpy.context.scene, mat)['fragment']
        bpy.data.materials.remove(mat)
        print('Converting shader lib')
        parts = fragment.rsplit('}',2)
        SHADER_LIB = \
"""
#ifdef GL_ES
#if __VERSION__ < 130
#extension GL_OES_standard_derivatives : enable
#extension GL_EXT_shader_texture_lod : enable
#else
#define texture2D texture
#define texture2DLod textureLod
#define textureCube texture
#define textureCubeLod textureLod
#define texture2DProj textureProj
#define sample sample_
#endif
precision highp float;
precision highp int;
#if __VERSION__ < 130
#ifdef GL_EXT_shader_texture_lod
#define texture2DLod texture2DLodEXT
#define textureCubeLod textureCubeLodEXT
#else
#define texture2DLod texture2D
#define textureCubeLod textureCube
#endif
#endif
#endif
""" \
        +defines+uniforms+(parts[0]+'}').replace('\r','')+'\n'
        functions = get_patched_functions(SHADER_LIB)
        # remove unused functions
        # we're adding '' and 'material_preview_matcap' to ensure we add
        # the preamble and uniforms/globals, respectively
        used = {'', 'material_preview_matcap', 'mul', 'color_to_blender_normal_new_shading', 'distance_based_roughness'}
        call = re.compile(r"\b\w+\s*\(", flags=re.DOTALL)
        def add_used(code):
            for name in call.findall(code):
                name = name[:-1]
                if name in functions and name not in used:
                    used.add(name)
                    add_used(functions[name])
        for m in mat_list:
            add_used(m['fragment'])
        print('GLSL functions: total', len(functions), 'used', len(used))

        SHADER_LIB = ''.join(f for k,f in functions.items() if k in used).encode('ascii', 'ignore').decode()
        # This section below is necessary because something is interpreted as non ascii for some reason
        # despite the line above (which is also necessary, mysteriously...)
        SHADER_LIB += """
        #ifdef SS_REFR
        uniform vec2 unfrefract_size_px, unfrefract_px_size;
        void screen_space_refraction(vec4 color, vec3 normal,
                float roughness, float ior, out vec4 out_col){
            vec2 limit = (unfrefract_size_px-.5) * unfrefract_px_size;
            vec2 uv = gl_FragCoord.xy * unfrefract_px_size;
            uv += normal.xy*(ior-1.);
            out_col = texture2D(unfrefract, min(uv, limit));
            out_col.r = srgb_to_linearrgb(out_col.r);
            out_col.g = srgb_to_linearrgb(out_col.g);
            out_col.b = srgb_to_linearrgb(out_col.b);
            // out_col = vec4(uv, texture2D(unfrefract, uv).g, 1.0);
        }
        #endif
        """
        splits = SHADER_LIB. split('BIT_OPERATIONS', 2)
        if len(splits) == 3:
            a,b,c = splits
            SHADER_LIB = a+'BIT_OPERATIONS\n#endif'+c
        if debug_lib:
            open('/tmp/shader_lib.orig.glsl','w').write((parts[0]+'}').replace('\r','')+'\n')
            open('/tmp/shader_lib.glsl','w').write(SHADER_LIB)

    return SHADER_LIB
